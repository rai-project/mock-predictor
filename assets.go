// Code generated by fileb0x at "2018-11-12 10:52:25.459247 -0600 CST m=+0.006216973" from config file "b0x.yml" DO NOT EDIT.
// modification hash(abe17d7a6c5f18453063d0c1bf20dcf4.bec78145df0e4c3f8c1a39843eef84db)

package mock

import (
	"bytes"
	"compress/gzip"
	"context"
	"io"
	"net/http"
	"os"
	"path"

	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct {
	// Prefix allows to limit the path of all requests. F.e. a prefix "css" would allow only calls to /css/*
	Prefix string
}

// FileMockYml is "/mock.yml"
var FileMockYml = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x04\xff\x54\x92\x41\x6e\xeb\x30\x0c\x44\xf7\x3a\xc5\x20\xc6\x5f\xfe\x22\xd9\x6a\xd1\x43\xf4\x06\xb2\x43\x27\x44\x6c\x51\xa0\xa8\x06\xbe\x7d\x21\xd9\x4d\xd4\x9d\xc4\x79\x9c\x11\x69\xc7\xb0\x92\xc7\x2a\xd3\x03\x03\xea\x05\x32\x63\x93\xa2\x58\xe5\x4a\x8b\x9b\x35\xac\xf4\x14\x7d\x78\x87\xa6\xbf\xe0\x97\x82\x59\x14\x76\xa7\xa3\x03\xf8\x26\xcd\x2c\xd1\xe3\xf2\x71\xc6\xd0\x81\x87\x80\x49\xa2\x69\xe0\x68\xee\xa8\xfc\xa2\xc7\x15\x1c\x67\xd1\x35\x18\x4b\x3d\x23\xd3\x1a\xa2\xf1\xf4\xd2\x77\xd5\x5d\x29\x4f\xca\xa9\x62\x1e\x9f\x0e\xf8\x22\x2b\x1a\x73\x7b\xcd\x12\x46\x5a\x70\xaa\xa3\x9d\xf0\x64\xbb\xe3\x72\x3e\xff\x43\x52\x19\xc3\xc8\x0b\xdb\x56\x6d\x10\xe2\x06\x8e\xa9\x18\xd8\x70\x23\xcb\x6e\xc0\xc2\x13\xc5\xdc\x56\xf1\x9e\xeb\x28\x7a\x94\xa8\x94\x4d\x79\x32\xba\xba\x61\x6f\xce\x30\xe9\xd8\x66\x98\xeb\xca\x06\xcc\xac\xd9\x76\x0a\xb6\x25\x6a\xa9\x6f\x5b\xe0\x7f\x2b\x7b\xf0\x1a\x6e\xe4\x00\x60\x40\x37\x59\xfd\x20\x15\xef\x7c\x1a\xd4\x21\xbe\x01\x2d\xf4\x70\x91\x62\xa9\xd8\xfe\x80\xda\xdc\x82\x65\x6e\xe7\x5d\x73\x68\x45\x8f\x99\x82\x15\xad\xc1\x03\x42\xef\xfa\x97\x47\x0a\xf5\x57\x30\x52\x87\x9e\xda\xb3\xa5\x58\x2a\x86\x25\x8c\xb4\xb8\x9f\x00\x00\x00\xff\xff\x61\xfd\x37\xf6\x54\x02\x00\x00")

func init() {
	err := CTX.Err()
	if err != nil {
		panic(err)
	}

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileMockYml)
	r, err = gzip.NewReader(rb)
	if err != nil {
		panic(err)
	}

	err = r.Close()
	if err != nil {
		panic(err)
	}

	f, err = FS.OpenFile(CTX, "/mock.yml", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		panic(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		panic(err)
	}

	err = f.Close()
	if err != nil {
		panic(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}

}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {
	path = hfs.Prefix + path

	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// WalkDirs looks for files in the given dir and returns a list of files in it
// usage for all files in the b0x: WalkDirs("", false)
func WalkDirs(name string, includeDirsInList bool, files ...string) ([]string, error) {
	f, err := FS.OpenFile(CTX, name, os.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}

	fileInfos, err := f.Readdir(0)
	if err != nil {
		return nil, err
	}

	err = f.Close()
	if err != nil {
		return nil, err
	}

	for _, info := range fileInfos {
		filename := path.Join(name, info.Name())

		if includeDirsInList || !info.IsDir() {
			files = append(files, filename)
		}

		if info.IsDir() {
			files, err = WalkDirs(filename, includeDirsInList, files...)
			if err != nil {
				return nil, err
			}
		}
	}

	return files, nil
}
